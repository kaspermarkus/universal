/**
GPII Mock Definitions for all platform-specific components

Copyright 2017 Raising the Floor - International
Copyright 2013 OCAD University
Copyright 2014 Lucendo Development Ltd.

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

The research leading to these results has received funding from the European Union's
Seventh Framework Programme (FP7/2007-2013) under grant agreement no. 289016.

You may obtain a copy of the License at
https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

"use strict";

var fluid = fluid || require("infusion"),
    gpii = fluid.registerNamespace("gpii");

fluid.defaults("gpii.test.common.exec", {
    gradeNames: ["fluid.component"],
    events: {
        onExecExit: null
    },
    invokers: {
//        exec:
    }
});

// Maintains a mock model of currently executing processes
fluid.defaults("gpii.test.integration.exec", {
    gradeNames: ["gpii.test.common.exec"],
    members: {
        processModel: [] // list of process objects
    },
    invokers: {
        exec: {
            funcName: "gpii.test.integration.exec.exec",
            args: ["{that}", "{arguments}.0", "{arguments}.1"]
        }
    }
});

gpii.test.integration.exec.exec = function (that, processSpec /*, expected */) {
    // TODO: actually determine that the required process was started using the mock model
    that.events.onExecExit.fire(true, processSpec);
};

fluid.defaults("gpii.test.integration.mockHolder", {
    gradeNames: "fluid.component",
    // TODO: Namespace these distributions so they can be overridden
    distributeOptions: [{
        record: {
            funcName: null,
            func: "{gpii.test.integration.mockHolder}.nameResolver.resolveName"
        },
        target: "{that lifecycleManager > nameResolver}.options.invokers.resolveName"
    }, {
        record: { // TODO: appears that this distribution has always been broken
            funcName: null,
            func: "{gpii.test.integration.deviceReporterAware}.resolveName"
        },
        target: "{that deviceReporter > nameResolver}.options.invokers.resolveName"
    }, {
        record: {
            funcName: null,
            func: "{gpii.test.integration.mockHolder}.mockPlatformReporter.reportPlatform"
        },
        target: "{that deviceReporter platformReporter}.options.invokers.reportPlatform"
    }, {
        target: "{that lifecycleManager > variableResolver}.options.components.resolverConfig.type",
        record: "gpii.test.integration.standardResolverConfig"
    }],
    components: {
        exec: {
            type: "gpii.test.integration.exec"
        },
        mockSettingsHandlers: {
            type: "gpii.test.integration.mockSettingsHandlerRegistry.universal"
        },
        mockDeviceReporters: {
            type: "gpii.test.integration.deviceReporterAware"
        },
        nameResolver: {
            type: "fluid.component",
            options: {
                invokers: {
                    resolveName: {
                        funcName: "gpii.test.integration.resolveName",
                        args: ["{mockSettingsHandlers}", "{mockDeviceReporters}", "{arguments}.0", "{arguments}.1"]
                    }
                }
            }
        }
    }
});

fluid.defaults("gpii.test.integration.standardResolverConfig", {
    gradeNames: "fluid.component",
    resolvers: {
        environment: "gpii.test.integration.environmentResolver"
    }
});


// Return the environment variable name unmodified
gpii.test.integration.environmentResolver = fluid.identity;

fluid.defaults("gpii.test.integration.mockHolder.windows", {
    gradeNames: ["gpii.test.integration.mockHolder"],
    components: {
        mockSettingsHandlers: {
            type: "gpii.test.integration.mockSettingsHandlerRegistry.windows"
        },
        mockPlatformReporter: {
            type: "gpii.test.integration.mockPlatformReporter",
            options: {
                platform: {
                    id: "win32",
                    version: "6.1.7601"
                }
            }
        }
    }
});


fluid.defaults("gpii.test.integration.mockHolder.linux", {
    gradeNames: ["gpii.test.integration.mockHolder"],
    components: {
        mockSettingsHandlers: {
            type: "gpii.test.integration.mockSettingsHandlerRegistry.linux"
        },
        mockPlatformReporter: {
            type: "gpii.test.integration.mockPlatformReporter",
            options: {
                platform: {
                    id: "linux",
                    version: "2.6.26"
                }
            }
        }
    }
});

fluid.defaults("gpii.test.integration.mockHolder.android", {
    gradeNames: ["gpii.test.integration.mockHolder"],
    components: {
        mockSettingsHandlers: {
            type: "gpii.test.integration.mockSettingsHandlerRegistry.android"
        },
        mockPlatformReporter: {
            type: "gpii.test.integration.mockPlatformReporter",
            options: {
                platform: {
                    id: "android",
                    version: "3.0.31"
                }
            }
        }
    }
});

fluid.defaults("gpii.test.integration.mockPlatformReporter", {
    gradeNames: ["fluid.component"],
    invokers: {
        reportPlatform: {
            funcName: "fluid.identity",
            args: "{that}.options.platform"
        }
    }
});

gpii.test.integration.mockExecHandler = function (command, args) {
    // TODO: we should record the executing process in a process model - ideally we should have a more reliable model of extracting what it is
    fluid.log("Mock exec handler for command ", command, " args ", args);
};

fluid.defaults("gpii.test.integration.mockExecHandler", {
    gradeNames: "fluid.function",
    argumentMap: {
        command: 0,
        args: 1
    }
});

gpii.test.integration.resolveName = function (settingsHandlerRegistry, deviceReporterAware, name, category) {
    if (category === "settingsHandler") {
        return settingsHandlerRegistry.resolveName(name);
    } else if (category === "deviceReporter") {
        return deviceReporterAware.resolveName(name);
    } else {
        return "gpii.test.integration.mockExecHandler";
    }
};

// cf. much less sophisticated mock in LifecycleManagerTest.js
fluid.defaults("gpii.test.integration.mockSettingsHandler", {
    gradeNames: ["fluid.component"],
    members: {
        settingsStore: {}
    },
    async: false,
    // must be configured for each settingsHandler instance to resolve to a path within
    // the options structure which determines a unique key for the particular payload
    // can also resolve to a function which returns such a key given the options
    optionsPathKey: null,
    invokers: {
        set: {
            funcName: "gpii.test.integration.mockSettingsHandler.set",
            args: ["{that}", "{arguments}.0"]
        },
        setImpl: {
            funcName: "gpii.test.integration.mockSettingsHandler.setImpl",
            args: ["{that}", "{arguments}.0", "{arguments}.1"]
                              // set payload, solutionId
        },
        get: {
            funcName: "gpii.test.integration.mockSettingsHandler.get",
            args: ["{that}", "{arguments}.0"]
        },
        getImpl: {
            funcName: "gpii.test.integration.mockSettingsHandler.getImpl",
            args: ["{that}", "{arguments}.0", "{arguments}.1"]
                            // get payload, solutionId
        }
    }
});

gpii.test.integration.resolveHandlerKey = function (that, payload, solutionId) {
    var pathKey = that.options.optionsPathKey;
    if (typeof(pathKey) === "string") {
        return fluid.get(payload.options, pathKey);
    } else if (typeof(pathKey) === "function") {
        return pathKey(payload.options, solutionId);
    }
};

gpii.test.integration.mockSettingsHandler.applySettings = function (store, settings) {
    fluid.each(settings, function (value, key) {
        if (value === undefined) {
            delete store[key];
        } else {
            store[key] = value;
        }
    });
};

gpii.test.integration.mockSettingsHandler.makeSetReturn = function (oldStore, settings) {
    return fluid.transform(settings, function (value, key) {
        return {
            oldValue: oldStore[key],
            value: value
        };
    });
};

gpii.test.integration.mockSettingsHandler.returnAsyncResponse = function (value, isAsync) {
    if (isAsync) {
        var togo = fluid.promise();
        gpii.invokeLater(function () {
            togo.resolve(value);
        }, 100);
        return togo;
    } else {
        return value;
    }
};

/**
 * Generate a structure containing slots for the current and previous settings
 * for the given solution.
 * @param that {Component}      Mock settings handler that tracks the settings
 *                              in its settings store.
 * @param payload {Object}      Contains settings and options that contain a
 *                              key to choose settings fromt the settings
 *                              handler's settings store.
 * @param solutionId {String}   The solution to check in the payload.
 * @return {Object}             An object containing "store" and "oldStore"
 *                              fields.
 */
gpii.test.integration.mockGenerateStores = function (that, payload, solutionId) {
    var key = gpii.test.integration.resolveHandlerKey(that, payload, solutionId);
    var oldStore = fluid.copy(that.settingsStore[key]) || {};
    var store = (that.settingsStore[key] = that.settingsStore[key] || {});
    return { store: store, oldStore: oldStore };
};

/**
 * Update the settings handler's setting store with the given settings, and
 * return the changes between the current settings in the store, and the new
 * settings values passed in.
 * @param settingsHandler {Component}   The mock settings handler that hasa
 *                                      settings store member and a key to
 *                                      choose a set of settings from that store.
 * @param payload {Object}              An object containing settings associated
 *                                      with a key.  The key is the same as that
 *                                      used to access the settings handler's
 *                                      settings store.
 * @param solutionId {String}           A string to choose a solution from the
 *                                      payload.
 * @return {Object}                     An object that for each setting
 *                                      references an object containing the old
 *                                      and new values.
 */
gpii.test.integration.mockUpdateSettingsStore = function (that, payload, solutionId) {
    var stores = gpii.test.integration.mockGenerateStores(that, payload, solutionId);
    var applySettings = function () {
        gpii.test.integration.mockSettingsHandler.applySettings(stores.store, payload.settings);
    };
    if (that.options.delaying && !payload.options.mockSync) {
        // behave, for example, like the real SPI settings handler - claim to apply settings immediately but don't actually do it till later
        gpii.invokeLater(applySettings, 5000);
    } else {
        applySettings();
    }
    return gpii.test.integration.mockSettingsHandler.makeSetReturn(stores.oldStore, payload.settings);
};

gpii.test.integration.mockSettingsHandler.setImpl = function (that, payload, solutionId) {
    var togo = gpii.test.integration.mockSettingsHandler.returnAsyncResponse(
        gpii.test.integration.mockUpdateSettingsStore(that, payload, solutionId),
        that.options.async
    );
    return togo;
};

gpii.test.integration.mockSettingsHandler.set = function (that, payload) {
    return gpii.settingsHandlers.invokeSettingsHandler(that.setImpl, payload);
};

gpii.test.integration.mockSettingsHandler.getImpl = function (that, payload, solutionId) {
    var key = gpii.test.integration.resolveHandlerKey(that, payload, solutionId);
    var store = that.settingsStore[key] || {};
    var response = fluid.transform(payload.settings, function (value, key) {
        return store[key];
    });
    var togo = gpii.test.integration.mockSettingsHandler.returnAsyncResponse(response, that.options.asyncGet);
    return togo;
};

gpii.test.integration.mockSettingsHandler.get = function (that, payload) {
    return gpii.settingsHandlers.invokeSettingsHandler(that.getImpl, payload);
};

// The platform-specific registry of mock settings handlers

gpii.test.integration.registrySettingsHandlerKey = function (options) {
    return options.hKey + "|" + options.path;
};

gpii.test.integration.flexibleHandlerKey = function (options, solutionId) {
    return solutionId + ".flexibleHandler";
};

gpii.test.integration.gsettingsLaunchKey = function (options) {
    return options.schema + "|" + options.key;
};

fluid.defaults("gpii.test.integration.mockSettingsHandlerRegistry", {
    gradeNames: ["fluid.component"],
    rootPath: "gpii.test.integration.mockSettingsHandlers", // the global names for mocks will be deposited in here
    members: {
        settingsHandlers: {}
    },
    invokers: {
        resolveName: {
            funcName: "gpii.test.integration.mockSettingsHandlerRegistry.resolveName",
            args: ["{that}", "{arguments}.0"]
        }
    },
    listeners: {
        "onCreate.populate": "gpii.test.integration.mockSettingsHandlerRegistry.populate"
    }
});

gpii.test.integration.mockSettingsHandlers = {};

gpii.test.integration.mockSettingsHandlerRegistry.populateOne = function (that, mock, key) {
    that.settingsHandlers[key] = mock;
    // Mount the mock handler at a global path
    var setPath = that.options.rootPath + "." + key + ".set";
    fluid.setGlobalValue(setPath, mock.set);
    fluid.setGlobalValue(that.options.rootPath + "." + key + ".get", mock.get);
};

gpii.test.integration.mockSettingsHandlerRegistry.populate = function (that) {
    fluid.each(that.options.settingsHandlers, function (options, key) {
        var mock;
        if (key === "gpii.windows.enableRegisteredAT") {
            mock = gpii.test.integration.mockEnableRegisteredAT(options);
        } else {
            mock = gpii.test.integration.mockSettingsHandler(options);
        }
        gpii.test.integration.mockSettingsHandlerRegistry.populateOne(that, mock, key);
    });
};

gpii.test.integration.mockSettingsHandlerRegistry.resolveName = function (that, name) {
    var mock = that.settingsHandlers[name];
    if (!mock) {
        var registered = fluid.keys(that.settingsHandlers).join(", ");
        fluid.fail("Error in settings handler mock configuration - handler " + name +
            " is not registered - registered handlers are " + registered);
    } else {
        return that.options.rootPath + "." + name;
    }
};

fluid.defaults("gpii.test.integration.mockSettingsHandlerRegistry.universal", {
    gradeNames: ["gpii.test.integration.mockSettingsHandlerRegistry"],
    settingsHandlers: {
        "gpii.settingsHandlers.INISettingsHandler": {
            optionsPathKey: "filename"
        },
        "gpii.settingsHandlers.XMLHandler": {
            optionsPathKey: "filename"
        },
        "gpii.settingsHandlers.JSONSettingsHandler": {
            optionsPathKey: "filename"
        },
        "gpii.launchHandlers.flexibleHandler": {
            optionsPathKey: gpii.test.integration.flexibleHandlerKey
        },
        "gpii.settingsHandlers.webSockets" : {},
        "gpii.settingsHandlers.noSettings": {}
    }
});

fluid.defaults("gpii.test.integration.mockSettingsHandlerRegistry.windows", {
    gradeNames: ["gpii.test.integration.mockSettingsHandlerRegistry.universal"],
    settingsHandlers: {
        "gpii.windows.registrySettingsHandler": {
            optionsPathKey: gpii.test.integration.registrySettingsHandlerKey
        },
        "gpii.windows.spiSettingsHandler": {
            // delaying: true,
            optionsPathKey: "setAction"
        },
        "gpii.windows.displaySettingsHandler": {},
        "gpii.windows.enableRegisteredAT": {
            optionsPathKey: "registryName"
        }
    }
});

fluid.defaults("gpii.test.integration.mockSettingsHandlerRegistry.linux", {
    gradeNames: ["gpii.test.integration.mockSettingsHandlerRegistry.universal"],
    settingsHandlers: {
        "gpii.gsettings": {
            optionsPathKey: "schema"
        },
        "gpii.orca": {
            async: true,
            asyncGet: true,
            optionsPathKey: "user"
        },
        "gpii.alsa": {
            optionsPathKey: "NONE"
        },
        "gpii.xrandr": {
            optionsPathKey: "NONE"
        },
        "gpii.gsettings.launch": {
            optionsPathKey: gpii.test.integration.gsettingsLaunchKey
        }
    }
});

fluid.defaults("gpii.test.integration.mockSettingsHandlerRegistry.android", {
    gradeNames: ["gpii.test.integration.mockSettingsHandlerRegistry.universal"],
    settingsHandlers: {
        "gpii.androidSettings": {
            optionsPathKey: "settingType"
        },
        "gpii.androidAudioManager.volume": {
            optionsPathKey: "NONE"
        },
        "gpii.androidPersistentConfiguration": {
            optionsPathKey: "NONE"
        }
    }
});

fluid.registerNamespace("gpii.test.integration.enableRegisteredAT");
fluid.defaults("gpii.test.integration.mockEnableRegisteredAT", {
    gradeNames: ["gpii.test.integration.mockSettingsHandler"],
    invokers: {
        getImpl: {
            funcName: "gpii.test.integration.enableRegisteredAT.getImpl",
            args: [ "{that}", "{arguments}.0" ]
                              // payload
        },
        setImpl: {
            funcName: "gpii.test.integration.enableRegisteredAT.setImpl",
            args: [ "{that}", "{arguments}.0", "{arguments}.1" ]
                              // payload, solutionId
        }
    }
});

gpii.test.integration.enableRegisteredAT.getImpl = function (that, payload) {
    var response = {};
    response.running = gpii.processReporter.handleIsRunning(payload.options);
    return gpii.test.integration.mockSettingsHandler.returnAsyncResponse(response, that.options.asyncGet);
};

gpii.test.integration.enableRegisteredAT.setImpl = function (that, payload, solutionId) {
    // Mock processes model -- simulate start/stop a solution
    var enable = payload.settings.running;
    var command = payload.options.isRunning[0].command;
    var processesBridge = gpii.test.integration.mockProcesses();
    var procInfo = gpii.test.integration.generateMockProcInfo(command, enable);
    var previousState;
    if (enable) {
        previousState = gpii.test.integration.startAT(processesBridge, procInfo);
    } else {
        previousState = gpii.test.integration.stopAT(processesBridge, procInfo);
    }
    // Settings store - whether the solution is active or not should be handled
    // by the processes bridge and process reporter, but other aspects of the
    // system depend on that.settingsStore.  The following transfers the
    // information in the mock process reporter model into the settings store.
    var stores = gpii.test.integration.mockGenerateStores(that, payload, solutionId);
    stores.oldStore.running = previousState;
    stores.store.running = enable;
    var response = gpii.test.integration.mockSettingsHandler.makeSetReturn(stores.oldStore, payload.settings);
    return gpii.test.integration.mockSettingsHandler.returnAsyncResponse(
        response,
        that.options.async
    );
};

fluid.defaults("gpii.test.integration.deviceReporterAware", {
    gradeNames: ["fluid.component"],
    rootPath: "gpii.test.integration.deviceReporterAware.mockDeviceReporters",
    members: {
        mockDeviceReporters: {},
        deviceReporters: {}
    },
    invokers: {
        resolveName: {
            funcName: "gpii.test.integration.deviceReporterAware.resolveName",
            args: ["{that}", "{arguments}.0"]
        }
    },
    listeners: {
        onCreate: "gpii.test.integration.deviceReporterAware.populate"
    }
});

gpii.test.integration.deviceReporterAware.mockDeviceReporters = {};

gpii.test.integration.deviceReporterAware.mockDeviceReporters.findNameInList = function (expectInstalled, name) {
    return expectInstalled.some(function (el) { return el === name; });
};

gpii.test.integration.deviceReporterAware.mockDeviceReporters.registryKeyExists = function (expectInstalled, hKey, path, subPath) {
    return expectInstalled.some(function (el) {
        return el.hKey === hKey && el.path === path && el.subPath === subPath;
    });
};

gpii.test.integration.deviceReporterAware.populate = function (that) {
    fluid.each(that.options.deviceReporters, function (options, key) {
        var mock = that.options.mockDeviceReporters[key];

        if (!mock) {
            var registered = fluid.keys(that.options.mockDeviceReporters).join(", ");
            fluid.fail("Error in dynamic device reporter mock configuration - handler " + key +
                " is not registered - registered handlers are " + registered);
        }

        var expectInstalled = [];
        fluid.each(that.options.deviceReporters[key].expectInstalled, function (item) {
            expectInstalled.push(item);
        });

        fluid.defaults(that.options.rootPath + "." + key, mock.defaults);

        var mockedFunction = gpii.test.integration.deviceReporterAware.mockDeviceReporters[mock.mockFunc].bind(undefined, expectInstalled);
        fluid.setGlobalValue(that.options.rootPath + "." + key, mockedFunction);
    });
};

gpii.test.integration.deviceReporterAware.resolveName = function (that, name) {
    var resolvedName;

    if (name === "gpii.deviceReporter.alwaysInstalled") {
        resolvedName = name;
    } else {
        resolvedName = that.options.rootPath + "." + name;
    }

    return resolvedName;
};

fluid.defaults("gpii.test.integration.deviceReporterAware.linux", {
    gradeNames: ["gpii.test.integration.deviceReporterAware"],
    mockDeviceReporters: {
        "gpii.packageKit.find": {
            mockFunc: "findNameInList",
            defaults: {
                gradeNames: "fluid.function",
                argumentMap: {
                    name: 0
                }
            }
        }
    }
});

fluid.defaults("gpii.test.integration.deviceReporterAware.windows", {
    gradeNames: "gpii.test.integration.deviceReporterAware",
    mockDeviceReporters: {
        "gpii.deviceReporter.registryKeyExists": {
            mockFunc: "registryKeyExists",
            defaults: {
                gradeNames: "fluid.function",
                argumentMap: {
                    hKey: 0,
                    path: 1,
                    subPath: 2
                }
            }
        }
    }
});

// ========================================
// Mock ProcessReporter and ProcessesBridge

fluid.registerNamespace("gpii.test.integration.processes");

gpii.test.integration.mockWindowsMagnifier = fluid.freezeRecursive({
    command: "Magnify.exe",
    pid: 5012,
    ppid: 968,
    uid: 501,
    gid: 20,
    fullPath: "",
    argv: [""],
    state: "Running"
});

gpii.test.integration.mockWindowsOSK = fluid.freezeRecursive({
    command: "osk.exe",
    pid: 6666,
    ppid: 968,
    uid: 501,
    gid: 20,
    fullPath: "",
    argv: [""],
    state: "Running"
});

// mock "firefox" process
gpii.test.integration.mockFirefox = fluid.freezeRecursive({
    command: "firefox",
    pid: 2563,
    ppid: 1,
    uid: 501,
    gid: -1,
    fullPath: "/Applications/Firefox.app/Contents/MacOS/firefox",
    argv: ["/Applications/Firefox.app/Contents/MacOS/firefox", "-foreground"],
    state: "Sleeping"
});

// mock 'gnome-shell' process
gpii.test.integration.mockGnomeShell = fluid.freezeRecursive({
    command: "gnome-shell",
    pid: 2563,
    ppid: 1,
    uid: 501,
    gid: -1,
    fullPath: "/usr/bin/gnome-shell",
    argv: [""],
    state: "Sleeping"
});

// Mock list of running processes.
gpii.test.integration.mockProcessesList = [
    gpii.test.integration.mockFirefox,
    gpii.test.integration.mockGnomeShell
];

/**
 * "Start" an AT, such as the magnifier.  Simulated by adding the running
 * mock process to the list of processes known to the given proceesesBridge, if
 * not already present in the list.  Returns whether the AT was already running.
 *
 * @param processesBridge {Component}
 * @param mockProcInfo {Object}
 * @return {Boolean}
 */
gpii.test.integration.startAT = function (processesBridge, mockProcInfo) {
    var currentState;
    var procInfo = processesBridge.findFirstProcessByCommand(mockProcInfo.command);
    // Start only if not running.
    if (procInfo === null) {
        currentState = false;
        processesBridge.getProcessList().push(mockProcInfo);
    } else {
        currentState = processesBridge.isRunning(procInfo.state);
    }
    return currentState;
};

/**
 * "Stop" an AT if running.  Simulated by removing the mock process from
 * the list of processes member of the given proceesesBridge, if present in the
 * list of processes.  Returns whether there was a process already running.
 *
 * @param processesBridge {Component}.
 * @param mockProcInfo {Object}
 * @return {Boolean}
 */
gpii.test.integration.stopAT = function (processesBridge, mockProcInfo) {
    var currentState;
    var procInfo = processesBridge.findFirstProcessByCommand(mockProcInfo.command);
    // Stop only if running.
    if (procInfo !== null) {
        currentState = processesBridge.isRunning(procInfo);
        var index = processesBridge.getProcessList().indexOf(procInfo);
        processesBridge.getProcessList().splice(index, 1);
    } else {
        currentState = false;
    }
    return currentState;
};

/**
 * Toggle the activation of gnome-shell magnifier.  This is simulated by setting
 * the mock gsetting org.gnome.desktop.a11y.applications "screen-reader-enabled"
 * setting to true or false.
 *
 * @param activeFlag {Boolean}.
 */
gpii.test.integration.gnomeShellMagnifier = {};
gpii.test.integration.gnomeShellMagnifier["org.gnome.desktop.a11y.applications"] = {};
gpii.test.integration.gnomeShellMagnifier["org.gnome.desktop.a11y.applications"]["screen-magnifier-enabled"] = false;

gpii.test.integration.startStopGnomeShellMagnifier = function (activeFlag) {
    gpii.test.integration.gnomeShellMagnifier["org.gnome.desktop.a11y.applications"]["screen-magnifier-enabled"] = activeFlag;
};

fluid.defaults("gpii.test.integration.mockProcesses", {
    gradeNames: ["gpii.processes", "gpii.contexts.test.integration"],
    members: {
        mockWindowsMagnifier: gpii.test.integration.mockWindowsMagnifier,
        mockWindowsOSK: gpii.test.integration.mockWindowsOSK
    },
    invokers: {
        getProcessList: {
            funcName: "gpii.test.integration.getProcessList",
            args: ["{arguments}.0"]
                   // identifier: process ID or command name; optional
        },
        generateMockProcInfo: {
            funcName: "gpii.test.integration.generateMockProcInfo",
            args: ["{arguments}.0"]
                   // command name
        }
    }
});

/**
 * Get the mock list of processes and look for the optionally identified
 * process, returning it/them if found.  The identifier can be a process id
 * (pid) or a command name.
 *
 * @param identifier {String}
 * @return {Array}
 */
gpii.test.integration.getProcessList = function (identifier) {
    var togo;
    var aProcInfo = null;
    if (identifier) {
        aProcInfo = fluid.find(
            gpii.test.integration.mockProcessesList,
            function (procInfo) {
                if (procInfo.pid === identifier || procInfo.name === identifier) {
                    return procInfo;
                }
            }, null
        );
    }
    if (aProcInfo) {
        togo = [aProcInfo];
    } else {
        togo = gpii.test.integration.mockProcessesList;
    }
    return togo;
};

/**
 * Return a mock process information object, with the given command name.
 *
 * @param commandName {String} - command name
 * @param runState {Boolean} - the run state to give the mock process; defaults
 *                             to false.
 * @return {Object} - a process information structure
 */
gpii.test.integration.generateMockProcInfo = function (command, runState) {
    return {
        command: command,
        pid: Math.trunc(Math.random() * 1000),
        ppid: Math.trunc(Math.random() * 1000),
        uid: Math.trunc(Math.random() * 1000),
        gid: Math.trunc(Math.random() * 1000),
        fullPath: "/bin/somewhere/over/the/rainbow",
        argv: ["foo", "bar", "55"],
        state: (runState ? "Running" : "NoSuchProcess")
    };
};

// These functions are referenced in the solutions registry entry
fluid.registerNamespace("gpii.processReporter");
fluid.defaults("gpii.processReporter.find", {
    gradeNames: "fluid.function",
    argumentMap: {
        command: 0
                 // command name of process to search for
    }
});
fluid.defaults("gpii.processReporter.checkSetting", {
    gradeNames: "fluid.function",
    argumentMap: {
        schema: 0,
        setting: 1,
        value: 2
    }
});

/**
 * Mock search for a process with the given cammand name.  The relevant mock
 * processes are listed in 'gpii.test.integration.mockProcessesList'.
 * @param commandName {String}.
 */
gpii.processReporter.find = function (commandName) {
    var running = false;
    var processesBridge = gpii.test.integration.mockProcesses();
    var theProcess = null;
    var procInfos = processesBridge.findSolutionsByCommands([commandName]);
    if (procInfos.length > 0) {
        theProcess = procInfos[0];
    }
    if (theProcess !== null) {
        running = processesBridge.isRunning(theProcess.state);
    }
    return running;
};

/**
 * Check if the given setting is set, although this is specific the value of
 * the mock gnome-shell magnifier setting using the schema name
 * "org.gnome.desktop.a11y.applications" and the setting
 * "screen-magnifier-enabled".  Returns a boolean indicating if the passed in
 * value matches the current setting.
 *
 * @param schema {String}
 * @param setting {String}
 * @param value {Any}
 * @return {Boolean}
 */
gpii.processReporter.checkSetting = function (schema, setting, value) {
    var actualValue = undefined;
    if (schema && setting) {
        actualValue = gpii.test.integration.gnomeShellMagnifier[schema][setting];
    }
    return value === actualValue;
};

// End Mock ProcessReporter
// =============================
